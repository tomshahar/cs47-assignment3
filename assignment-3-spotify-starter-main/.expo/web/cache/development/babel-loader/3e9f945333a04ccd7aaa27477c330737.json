{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _excluded = [\"windowFeatures\"];\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport { useCallback, useMemo, useEffect, useState } from 'react';\nimport { AuthRequest } from \"./AuthRequest\";\nimport { resolveDiscoveryAsync } from \"./Discovery\";\nexport function useAutoDiscovery(issuerOrDiscovery) {\n  var _useState = useState(null),\n    _useState2 = _slicedToArray(_useState, 2),\n    discovery = _useState2[0],\n    setDiscovery = _useState2[1];\n  useEffect(function () {\n    var isAllowed = true;\n    resolveDiscoveryAsync(issuerOrDiscovery).then(function (discovery) {\n      if (isAllowed) {\n        setDiscovery(discovery);\n      }\n    });\n    return function () {\n      isAllowed = false;\n    };\n  }, [issuerOrDiscovery]);\n  return discovery;\n}\nexport function useLoadedAuthRequest(config, discovery, AuthRequestInstance) {\n  var _useState3 = useState(null),\n    _useState4 = _slicedToArray(_useState3, 2),\n    request = _useState4[0],\n    setRequest = _useState4[1];\n  var scopeString = useMemo(function () {\n    var _config$scopes;\n    return (_config$scopes = config.scopes) == null ? void 0 : _config$scopes.join(',');\n  }, [config.scopes]);\n  var extraParamsString = useMemo(function () {\n    return JSON.stringify(config.extraParams || {});\n  }, [config.extraParams]);\n  useEffect(function () {\n    var isMounted = true;\n    if (discovery) {\n      var _request = new AuthRequestInstance(config);\n      _request.makeAuthUrlAsync(discovery).then(function () {\n        if (isMounted) {\n          setRequest(_request);\n        }\n      });\n    }\n    return function () {\n      isMounted = false;\n    };\n  },\n  [discovery == null ? void 0 : discovery.authorizationEndpoint, config.clientId, config.redirectUri, config.responseType, config.prompt, config.clientSecret, config.codeChallenge, config.state, config.usePKCE, scopeString, extraParamsString]);\n  return request;\n}\nexport function useAuthRequestResult(request, discovery) {\n  var customOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _useState5 = useState(null),\n    _useState6 = _slicedToArray(_useState5, 2),\n    result = _useState6[0],\n    setResult = _useState6[1];\n  var promptAsync = useCallback(function _callee() {\n    var _customOptions$window;\n    var _ref,\n      _ref$windowFeatures,\n      windowFeatures,\n      options,\n      inputOptions,\n      result,\n      _args = arguments;\n    return _regeneratorRuntime.async(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _ref = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n            _ref$windowFeatures = _ref.windowFeatures, windowFeatures = _ref$windowFeatures === void 0 ? {} : _ref$windowFeatures, options = _objectWithoutProperties(_ref, _excluded);\n            if (!(!discovery || !request)) {\n              _context.next = 4;\n              break;\n            }\n            throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n          case 4:\n            inputOptions = _objectSpread(_objectSpread(_objectSpread({}, customOptions), options), {}, {\n              windowFeatures: _objectSpread(_objectSpread({}, (_customOptions$window = customOptions.windowFeatures) != null ? _customOptions$window : {}), windowFeatures)\n            });\n            _context.next = 7;\n            return _regeneratorRuntime.awrap(request == null ? void 0 : request.promptAsync(discovery, inputOptions));\n          case 7:\n            result = _context.sent;\n            setResult(result);\n            return _context.abrupt(\"return\", result);\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, null, null, null, Promise);\n  },\n  [request == null ? void 0 : request.url, discovery == null ? void 0 : discovery.authorizationEndpoint]);\n  return [result, promptAsync];\n}\nexport function useAuthRequest(config, discovery) {\n  var request = useLoadedAuthRequest(config, discovery, AuthRequest);\n  var _useAuthRequestResult = useAuthRequestResult(request, discovery),\n    _useAuthRequestResult2 = _slicedToArray(_useAuthRequestResult, 2),\n    result = _useAuthRequestResult2[0],\n    promptAsync = _useAuthRequestResult2[1];\n  return [request, result, promptAsync];\n}","map":{"version":3,"mappings":"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","names":["useCallback","useMemo","useEffect","useState","AuthRequest","resolveDiscoveryAsync","useAutoDiscovery","issuerOrDiscovery","discovery","setDiscovery","isAllowed","then","useLoadedAuthRequest","config","AuthRequestInstance","request","setRequest","scopeString","scopes","join","extraParamsString","JSON","stringify","extraParams","isMounted","makeAuthUrlAsync","authorizationEndpoint","clientId","redirectUri","responseType","prompt","clientSecret","codeChallenge","state","usePKCE","useAuthRequestResult","customOptions","result","setResult","promptAsync","windowFeatures","options","Error","inputOptions","url","useAuthRequest"],"sourceRoot":"","sources":["../src/AuthRequestHooks.ts"],"sourcesContent":["import { useCallback, useMemo, useEffect, useState } from 'react';\n\nimport { AuthRequest } from './AuthRequest';\nimport { AuthRequestConfig, AuthRequestPromptOptions } from './AuthRequest.types';\nimport { AuthSessionResult } from './AuthSession.types';\nimport { DiscoveryDocument, IssuerOrDiscovery, resolveDiscoveryAsync } from './Discovery';\n\n/**\n * Fetch the discovery document from an OpenID Connect issuer.\n *\n * @param issuerOrDiscovery\n */\nexport function useAutoDiscovery(issuerOrDiscovery: IssuerOrDiscovery): DiscoveryDocument | null {\n  const [discovery, setDiscovery] = useState<DiscoveryDocument | null>(null);\n\n  useEffect(() => {\n    let isAllowed = true;\n    resolveDiscoveryAsync(issuerOrDiscovery).then((discovery) => {\n      if (isAllowed) {\n        setDiscovery(discovery);\n      }\n    });\n\n    return () => {\n      isAllowed = false;\n    };\n  }, [issuerOrDiscovery]);\n\n  return discovery;\n}\n\nexport function useLoadedAuthRequest(\n  config: AuthRequestConfig,\n  discovery: DiscoveryDocument | null,\n  AuthRequestInstance: typeof AuthRequest\n): AuthRequest | null {\n  const [request, setRequest] = useState<AuthRequest | null>(null);\n  const scopeString = useMemo(() => config.scopes?.join(','), [config.scopes]);\n  const extraParamsString = useMemo(\n    () => JSON.stringify(config.extraParams || {}),\n    [config.extraParams]\n  );\n  useEffect(\n    () => {\n      let isMounted = true;\n\n      if (discovery) {\n        const request = new AuthRequestInstance(config);\n        request.makeAuthUrlAsync(discovery).then(() => {\n          if (isMounted) {\n            setRequest(request);\n          }\n        });\n      }\n      return () => {\n        isMounted = false;\n      };\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      discovery?.authorizationEndpoint,\n      config.clientId,\n      config.redirectUri,\n      config.responseType,\n      config.prompt,\n      config.clientSecret,\n      config.codeChallenge,\n      config.state,\n      config.usePKCE,\n      scopeString,\n      extraParamsString,\n    ]\n  );\n  return request;\n}\n\ntype PromptMethod = (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>;\n\nexport function useAuthRequestResult(\n  request: AuthRequest | null,\n  discovery: DiscoveryDocument | null,\n  customOptions: AuthRequestPromptOptions = {}\n): [AuthSessionResult | null, PromptMethod] {\n  const [result, setResult] = useState<AuthSessionResult | null>(null);\n\n  const promptAsync = useCallback(\n    async ({ windowFeatures = {}, ...options }: AuthRequestPromptOptions = {}) => {\n      if (!discovery || !request) {\n        throw new Error('Cannot prompt to authenticate until the request has finished loading.');\n      }\n      const inputOptions = {\n        ...customOptions,\n        ...options,\n        windowFeatures: {\n          ...(customOptions.windowFeatures ?? {}),\n          ...windowFeatures,\n        },\n      };\n      const result = await request?.promptAsync(discovery, inputOptions);\n      setResult(result);\n      return result;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [request?.url, discovery?.authorizationEndpoint]\n  );\n\n  return [result, promptAsync];\n}\n\n/**\n * Load an authorization request.\n * Returns a loaded request, a response, and a prompt method.\n * When the prompt method completes then the response will be fulfilled.\n *\n * @param config\n * @param discovery\n */\nexport function useAuthRequest(\n  config: AuthRequestConfig,\n  discovery: DiscoveryDocument | null\n): [\n  AuthRequest | null,\n  AuthSessionResult | null,\n  (options?: AuthRequestPromptOptions) => Promise<AuthSessionResult>\n] {\n  const request = useLoadedAuthRequest(config, discovery, AuthRequest);\n  const [result, promptAsync] = useAuthRequestResult(request, discovery);\n  return [request, result, promptAsync];\n}\n"]},"metadata":{},"sourceType":"module"}